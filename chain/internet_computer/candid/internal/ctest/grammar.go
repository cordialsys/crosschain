// Package ctest is autogenerated by https://github.com/cordialsys/crosschain/chain/internet_computer/candid/upeg. DO NOT EDIT.
package ctest

import (
    "github.com/cordialsys/crosschain/chain/internet_computer/candid/parser"
    "github.com/cordialsys/crosschain/chain/internet_computer/candid/parser/op"
)

var (
    TestData = op.Capture{Name: "TestData", Value: op.OneOrMore{Value: op.Or{Comment, Test, EndLine}}}
    Comment = op.Or{op.And{"/*", Ws, MultiComment, Ws, "*/"}, op.And{op.And{"//", op.Optional{Value: CommentText}}, EndLine}}
    CommentText = op.Capture{Name: "CommentText", Value: op.ZeroOrMore{Value: op.Or{op.RuneRange{Min: 0x00, Max: 0x09}, op.RuneRange{Min: 0x0B, Max: 0x0C}, op.RuneRange{Min: 0x0E, Max: 0xD7FF}, op.RuneRange{Min: 0xE000, Max: 0x10FFFF}}}}
    MultiComment = op.ZeroOrMore{Value: op.Or{op.RuneRange{Min: 0x00, Max: 0x29}, op.RuneRange{Min: 0x2B, Max: 0x10FFFF}, op.And{rune(0x2A), op.Or{op.RuneRange{Min: 0x00, Max: 0x2E}, op.RuneRange{Min: 0x30, Max: 0x10FFFF}}}, EndLine}}
    Ws = op.ZeroOrMore{Value: op.Or{' ', rune(0x09), EndLine}}
    EndLine = op.Or{rune(0x0A), rune(0x0D), op.And{rune(0x0D), rune(0x0A)}}
    Test = op.Capture{Name: "Test", Value: op.And{"assert ", Input, Ws, op.Or{TestGoodTmpl, TestBadTmpl, TestTest}, op.Optional{Value: op.And{op.OneOrMore{Value: ' '}, Description}}, ';'}}
    TestGoodTmpl = op.And{':', Ws, TestGood}
    TestGood = op.Capture{Name: "TestGood", Value: ValuesBr}
    TestBadTmpl = op.And{"!:", Ws, TestBad}
    TestBad = op.Capture{Name: "TestBad", Value: ValuesBr}
    TestTest = op.Capture{Name: "TestTest", Value: op.And{"==", Ws, Input, Ws, ':', Ws, ValuesBr}}
    ValuesBr = op.Or{"()", op.And{'(', Values, op.ZeroOrMore{Value: op.And{", ", Values}}, ')'}}
    Values = op.Or{Null, Bool, Nat, Int, Float, Text, Reserved, Empty, Opt}
    Null = op.Capture{Name: "Null", Value: "null"}
    Bool = op.Capture{Name: "Bool", Value: "bool"}
    Nat = op.Capture{Name: "Nat", Value: op.And{"nat", op.Optional{Value: Base}}}
    Int = op.Capture{Name: "Int", Value: op.And{"int", op.Optional{Value: Base}}}
    Float = op.Capture{Name: "Float", Value: op.And{"float", Base}}
    Base = op.Capture{Name: "Base", Value: op.OneOrMore{Value: Digit}}
    Text = op.Capture{Name: "Text", Value: "text"}
    Reserved = op.Capture{Name: "Reserved", Value: "reserved"}
    Empty = op.Capture{Name: "Empty", Value: "empty"}
    Opt = op.Capture{Name: "Opt", Value: op.And{"opt ", op.Reference{Name: "Values"}}}
    Input = op.Or{BlobInputTmpl, TextInputTmpl}
    TextInputTmpl = op.And{rune(0x22), TextInput, rune(0x22)}
    TextInput = op.Capture{Name: "TextInput", Value: String}
    BlobInputTmpl = op.And{"blob ", rune(0x22), BlobInput, rune(0x22)}
    BlobInput = op.Capture{Name: "BlobInput", Value: op.ZeroOrMore{Value: op.Or{BlobAlpha, op.And{'\\', BlobHex}}}}
    BlobAlpha = op.Capture{Name: "BlobAlpha", Value: op.OneOrMore{Value: op.Or{op.RuneRange{Min: 0x41, Max: 0x5A}, op.RuneRange{Min: 0x61, Max: 0x7A}}}}
    BlobHex = op.Capture{Name: "BlobHex", Value: op.Repeat{Min: 2, Max: 2, Value: op.Or{op.RuneRange{Min: 0x30, Max: 0x39}, op.RuneRange{Min: 0x41, Max: 0x46}, op.RuneRange{Min: 0x61, Max: 0x66}}}}
    Description = op.Capture{Name: "Description", Value: op.And{rune(0x22), String, rune(0x22)}}
    String = op.ZeroOrMore{Value: Char}
    Char = op.Or{EscapedDQuote, UChar}
    UChar = op.Or{op.RuneRange{Min: 0x20, Max: 0x21}, op.RuneRange{Min: 0x23, Max: 0x10FFFF}}
    EscapedDQuote = op.And{rune(0x5C), rune(0x22)}
    Digit = op.RuneRange{Min: 0x30, Max: 0x39}
    Hex = op.Or{Digit, op.RuneRange{Min: 0x41, Max: 0x46}, op.RuneRange{Min: 0x61, Max: 0x66}}
)
func NewParser(input []rune) (*parser.Parser, error) {
    p, err := parser.New(input)
    if err != nil {
        return nil, err
    }
    p.Rules["Values"] = Values
    return p, nil
}
