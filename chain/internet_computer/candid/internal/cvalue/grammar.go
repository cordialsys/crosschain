// Package cvalue is autogenerated by https://github.com/0x51-dev/upeg. DO NOT EDIT.
package cvalue

import (
    "github.com/0x51-dev/upeg/parser"
    "github.com/0x51-dev/upeg/parser/op"
)

var (
    Values = op.Capture{Name: "Values", Value: op.Or{op.And{'(', Sp, op.Optional{Value: op.And{Value, op.ZeroOrMore{Value: op.And{Sp, ',', Sp, Value}}}}, Sp, ')'}, Value}}
    Value = op.Or{OptValue, Num, Bool, Null, Text, Record, Variant, Principal, Vec, Blob}
    OptValue = op.Capture{Name: "OptValue", Value: op.And{"opt", Spp, op.Or{Num, Bool, Null, Text, Record, Variant, Principal, Vec, Blob}}}
    Num = op.Capture{Name: "Num", Value: op.And{NumValue, op.Optional{Value: op.And{Sp, ':', Sp, NumType}}}}
    NumValue = op.Capture{Name: "NumValue", Value: op.And{op.Optional{Value: '-'}, Digit, op.ZeroOrMore{Value: op.And{op.Optional{Value: '_'}, Digit}}, op.Optional{Value: op.And{'.', op.Optional{Value: op.And{Digit, op.ZeroOrMore{Value: op.And{op.Optional{Value: '_'}, Digit}}}}}}}}
    NumType = op.Capture{Name: "NumType", Value: op.Or{"nat8", "nat16", "nat32", "nat64", "nat", "int8", "int16", "int32", "int64", "int", "float32", "float64"}}
    Bool = op.And{BoolValue, op.Optional{Value: op.And{Sp, ':', Sp, "bool"}}}
    BoolValue = op.Capture{Name: "BoolValue", Value: op.Or{"true", "false"}}
    Blob = op.Capture{Name: "Blob", Value: op.And{"blob", Spp, rune(0x22), op.ZeroOrMore{Value: op.Repeat{Min: 2, Max: 2, Value: Hex}}, rune(0x22)}}
    Null = op.Capture{Name: "Null", Value: "null"}
    Principal = op.Capture{Name: "Principal", Value: op.And{"principal", Spp, TextValue}}
    Text = op.Capture{Name: "Text", Value: op.And{TextValue, op.Optional{Value: op.And{Sp, ':', Sp, "text"}}}}
    TextValue = op.Capture{Name: "TextValue", Value: op.And{rune(0x22), op.ZeroOrMore{Value: Char}, rune(0x22)}}
    Record = op.Capture{Name: "Record", Value: op.And{"record", Sp, '{', Ws, op.Optional{Value: RecordFields}, Ws, '}'}}
    RecordFields = op.And{RecordField, Sp, op.ZeroOrMore{Value: op.And{';', Ws, RecordField, Sp}}, op.Optional{Value: ';'}}
    RecordField = op.Capture{Name: "RecordField", Value: op.And{Id, Sp, '=', Sp, op.Reference{Name: "Value"}}}
    Variant = op.Capture{Name: "Variant", Value: op.And{"variant", Sp, '{', Ws, VariantField, Ws, '}'}}
    VariantField = op.And{Id, op.Optional{Value: op.And{Sp, '=', Sp, op.Reference{Name: "Value"}}}, op.Optional{Value: ';'}}
    Vec = op.Capture{Name: "Vec", Value: op.And{"vec", Sp, '{', Ws, op.Optional{Value: VecFields}, Ws, '}'}}
    VecFields = op.And{op.Reference{Name: "Value"}, Sp, op.ZeroOrMore{Value: op.And{';', Ws, op.Reference{Name: "Value"}, Sp}}, op.Optional{Value: ';'}}
    Id = op.Capture{Name: "Id", Value: op.And{op.Or{Letter, '_'}, op.ZeroOrMore{Value: op.Or{Letter, Digit, '_'}}}}
    Sp = op.ZeroOrMore{Value: ' '}
    Spp = op.And{' ', Sp}
    Ws = op.ZeroOrMore{Value: op.Or{' ', rune(0x09), rune(0x0A), op.And{rune(0x0D), rune(0x0A)}, rune(0x0D)}}
    Char = op.Or{Utf, op.And{ESC, op.Repeat{Min: 2, Max: 2, Value: Hex}}, op.And{ESC, Escape}, op.And{"\\u{", HexNum, '}'}}
    HexNum = op.And{Hex, op.ZeroOrMore{Value: op.And{op.Optional{Value: '_'}, Hex}}}
    Utf = op.Or{Ascii, UtfEnc}
    UtfEnc = op.Or{op.And{op.RuneRange{Min: 0xC2, Max: 0xDF}, Utfcont}, op.And{rune(0xE0), op.RuneRange{Min: 0xA0, Max: 0xBF}, Utfcont}, op.And{rune(0xED), op.RuneRange{Min: 0x80, Max: 0x9F}, Utfcont}, op.And{op.RuneRange{Min: 0xE1, Max: 0xEC}, op.Repeat{Min: 2, Max: 2, Value: Utfcont}}, op.And{op.RuneRange{Min: 0xEE, Max: 0xEF}, op.Repeat{Min: 2, Max: 2, Value: Utfcont}}, op.And{rune(0xF0), op.RuneRange{Min: 0x90, Max: 0xBF}, op.Repeat{Min: 2, Max: 2, Value: Utfcont}}, op.And{rune(0xF4), op.RuneRange{Min: 0x80, Max: 0x8F}, op.Repeat{Min: 2, Max: 2, Value: Utfcont}}, op.And{op.RuneRange{Min: 0xF1, Max: 0xF3}, op.Repeat{Min: 3, Max: 3, Value: Utfcont}}}
    Utfcont = op.RuneRange{Min: 0x80, Max: 0xBF}
    Ascii = op.Or{op.RuneRange{Min: 0x20, Max: 0x21}, op.RuneRange{Min: 0x23, Max: 0x5B}, op.RuneRange{Min: 0x5D, Max: 0x7E}}
    Escape = op.Or{'n', 'r', 't', ESC, rune(0x22), rune(0x27)}
    Letter = op.Or{op.RuneRange{Min: 0x41, Max: 0x5A}, op.RuneRange{Min: 0x61, Max: 0x7A}}
    Digit = op.RuneRange{Min: 0x30, Max: 0x39}
    Hex = op.Or{Digit, op.RuneRange{Min: 0x41, Max: 0x46}, op.RuneRange{Min: 0x61, Max: 0x66}}
    ESC = rune(0x5C)
)
func NewParser(input []rune) (*parser.Parser, error) {
    p, err := parser.New(input)
    if err != nil {
        return nil, err
    }
    p.Rules["Value"] = Value
    return p, nil
}
